### 초기화 목록

초기화 목록(초기화 리스트)을 사용해야 하는 경우 (선언과 동시에 초기화 해야 하는 경우)

1. **상수 멤버**를 초기화 할 때

   상수 멤버는 const가 붙은 변수를 말한다. 상수 멤버는 선언만 하면 안 되고 **반드시** 초기화를 해야한다. 

2. **참조자 멤버**를 초기화 할 때 (레퍼런스 멤버)

   &변수

   > 레퍼런스(참조자)란? 포인터와의 차이는?
   >
   > * null이 될 수 없다. 포인터의 잘못된 참조로 발생하는 오류를 막을 수 있다. (포인터는 null값 허용)
   > * 참조 대상을 직접 할당한다. (주소값 할당 x)
   > * 포인터랑 비슷한데 포인터 연산자를 안 쓰고 접근할 수 있다고 보면 될 것 같다. 더 안전한 포인터이다. 레퍼런스의 값을 변경하면 레퍼런스가 참조하고 있는 실제 변수의 값이 변경된다.
   > * 참조 원본인 값을 수정하면 참조자 값도 수정된다.

   **반드시** 초기화를 해야 한다.

3. 클래스 안에서 다른 클래스 객체 초기화

   클래스 안에서 다른 클래스의 객체를 가지고 있을 때, 즉 has-a 관계일 때도 생성자에서 initializer list를 이용해 초기화 시켜줘야 한다.

   ```c++
   class AA
   {
    private:
       int a,b;
    public
       AA(int x, int  y): a(x),b(y){}
   };
   
   class BB
   {
    private:
      AA aa;
    public:
     BB():aa(10,20){}
   };
   ```

4. 상속받은 멤버 초기화

   상속받은 멤버는 자식 클래스에서 직접 초기화 할 수 없다. 초기화 작업을 부모에게 요청해야 한다.

   ```C++
   class Parent
   {
   public:
       int P1, P2;
       Parent(int i, int j)
       { 
           P1 = i;
           P2 = j;
       }
   };
   
   class Test : public Parent
   {
   public:
       int T3;
       Test(int i, int j, int k) : Parent(i, j)
       {
           T3 = k;
       }
   };
   ```

   

**장점**

초기화 리스트를 사용하지 않는다면 변수의 메모리 공간이 먼저 만들어지고 만들어진 메모리에 대입되지만, 초기화 리스트를 사용하면 메모리 공간이 만들어지면서 초기화 돼서 더 효율적이다.

### 동적 객체 생성 소멸

```c++
CTest* pDataF = new CTest[3]{1,2,3};
CTest* pData = new CTest[3]; // 생성자가 세 번 호출된다.
delete[] pDataF;
delete[] pData; // 소멸자가 세 번 호출 된다. 배열로 생성한 것은 반드시 배열로 삭제한다.
```

> 질문
>
> > ```cpp
> >  CTest pdata[3]{ 20,30,10 };
> >  delete[] pdata;
> > ```
> >
> > 포인터 배열이 아니라 그냥 배열일 경우 오류가 난다. 왜?

```cpp
CTest*	pData[10];
```

위는 객체 포인터 배열을 선언한 것이지 객체를 생성한 것이 아니다. 그러므로 생성자가 호출되지 않는다.

```cpp
pData[i] = new CTest(i);
```

하면 객체가 동적 생성된다. (for문 사용해서 생성과 소멸 한다.)

