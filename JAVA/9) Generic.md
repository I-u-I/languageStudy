## 이것이 자바다 제네릭

제네릭은 클래스에서 사용할 타입을 클래스 외부에서 설정하는 것이다. 제네릭 타입으로는 참조형 데이터 타입만 설정 가능하다. (int, char와 같은 기본 자료형은 사용할 수 없다. Wrapper class 사용.)

(제네릭을 사용하면 하나의 코드를 다양한 데이터 타입에 대해 사용할 수 있다.)

### 장점

- 강한 타입 체크

  강한 타입 체크로 타입 에러가 **컴파일 시**에 난다. (실행 시 타입 에러가 나는 것보단 컴파일 시에 나는 게 좋다.)

- 타입 변환 제거

  ```java
  ArrayList list = new ArrayList(); //제네릭을 사용하지 않을경우
  list.add("test");
  String temp = (String) list.get(0); //타입변환이 필요함
          
  ArrayList<String> list2 = new ArrayList(); //제네릭을 사용할 경우
  list2.add("test");
  temp = list2.get(0); //타입변환이 필요없음
  ```

  문자열로 저장했지만 요소를 찾아올 때 다시 String으로 타입 변환을 해야한다. 하지만 제네릭을 사용하면 List에 저장되는 요소의 타입을 제안하기 때문에 요소를 찾아올 때 타입 변환을 할 필요가 없다. (= 프로그램 성능 향상)



### 제네릭 타입

: 타입을 파라미터로 가지는 클래스와 인터페이스.

```java
public class 클래스명<타입 파라미터> {...}
public interface 인터페이스명<타입 파라미터> {...}
```

Object 타입을 사용하면 모든 객체를 저장할 수 있지만 저장 시에도 타입 변환이 발생하고, 불러올 때도 타입 변환이 발생한다.

- 제네릭은 클래스 설계할 때 구체적인 타입을 명시하지 않고, 타입 파라미터로 대체 한 후 클래스가 사용될 때 구체적인 타입을 지정한다.

```java
public class 클래스명<T>{
    privat T t;
    public T get(){return t;}
}
```

타입 파라미터를 사용하면

```JAVA
Box<String> box = new Box<String>();
```

객체를 생성할 대 구체적인 타입으로 변경된다. (타입 파라미터인 T는 String 타입으로 변경된다.)

>  타입 파라미터는 일반적으로 대문자 알파벳 한 글자로 표현한다. 타처음에는 타입 파라미터도 하나의 타입이라고 생각할 수 있는데 그게 아니라 객체를 생성할 때 지정해주는 **타입을 담는 변수라고 생각하면 편하다**.

### 타입 파라미터

[^타입 파라미터]: 코드 작성 시 구체적인 타입으로 **대체되어** 다양한 코드를 생성하도록 해준다.

타입 파라미터로 배열을 생성하려면 new T[n]이 아닌 (T[])(new Object[n])으로 생성해야 한다.

#### 멀티 타입 파라미터

두 개 이상의 타입 파라미터를 사용할 수 있다.

```java
public class 클래스명<T, M> {
    private T kind;
    private M model;
}
main
{
    클래스명<Integer, String> 객체명 = new 클래스명<>;
}
```

#### 제한된 타입 파라미터

메서드에서 타입 파라미터에 지정되는 구체적인 타입을 제한할 때 사용한다. 타입 파라미터 뒤에 extends로 상위 타입을 명시하면 된다. (인터페이스도 가능, 인터페이스도 extends를 사용한다.)

```java
pulbic <타입파라미터 extends 상위타입> 리턴타입 메소드(매개변수,...){...}
```

> BoundedTypeParmeter 패키지에 예제



### 제네릭 메소드

: 매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메소드.

리턴 타입 앞에 타입 파라미터를 기술해야 한다.

```java
public <타입 파라미터,...> 리턴타입 메소드명(매개변수,...){...}
```

호출 방법

```java
리턴타입 변수명 = <구체적타입> 메소드명(매개값);
리턴타입 변수명 = 메소드명(매개값);
```

> GenericMethod 패키지에 예제



### 와일드 카드 타입

제네릭 타입을 매개값이나 리턴 타입으로 사용할 때 구체적인 타입 대신 와일드 카드를 사용 가능하다. 제네릭 클래스 인스턴스 생성에는 사용할 수 없다.

- <?> 

  - Unbounded wildcard type (Unbounded: 한이 없는, 무한한)
  - 모든 클래스나 인터페이스 타입이 올 수 있다.

- <? extends 상위타입>

  -  Upper bounded wildcard

  - 자기 자신과 자식 객체만 허용

  - 상한 제한 추가 시 인스턴스(인자로 전달되는 매개변수)에서 꺼내는 것은 가능하지만 넣는 것(set)은 불가능해진다. 

    [자세한 설명]: https://vvshinevv.tistory.com/56	" 상한 제한과 하한 제한의 목적"

- <? super 하위타입>

  - Lower bounded wildcard
  - 자기 자신과 부모 객체만 허용
  - 하한 제한 추가 시 인스턴스에 넣는 것은 가능하지만 꺼내는 것(get)은 불가능하다.



### 제네릭타입 상속

자식 제네릭 타입은 추가적인 타입 파라미터를 가질 수 있다.

```java
public class ChildProduct<T, M C> extends Product<T, M>{...}
```

제네릭 인터페이스를 구현한 클래스도 제네릭 타입이 되어야 한다.