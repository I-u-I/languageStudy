[^익명 함수]: 함수 리터럴 방식으로 만들어진 이름 없는 함수이다. (함수를 재사용하지 않을 경우 만듦.)
[^함수 리터럴 방식]: 함수를 변수에 담는 방식이다.

## 람다식

```java
(타입 매개변수)->{실행문;...};
```

자바 8부터 제공한다. 익명 함수를 생성하기 위해 람다식을 사용한다. y=f(x) 형태로 (x에 값을 주면 y가 얻어지는) 함수적 프로그래밍 기법이다. -> 데이터를 매개값으로 전달하고 결과를 받는다.

> **약식 방법**
>
> > 1. 타입 생략이 가능하다.
> > 2. 하나의 매개변수나 하나의 실행문만 있을 경우에 괄호나 중괄호를 생략할 수 있다.
> > 3. return문만 있을 경우 return문 생략이 가능하다.
> >
> > ```java
> > a -> {System.out.print(a);};
> > (x,y)-> x+y;
> > ```

JAVA는 람다식을 함수적 인터페이스의 **익명 구현 객체**로 취급한다.

[^함수적 인터페이스]: 하나의 메소드만을 정의하고 있는 인터페이스

그러니까 밑 코드는

```java
Runnable A = ()->{...};
인터페이스 변수 = 람다식;
```

Runnable 인터페이스의 메소드를 구현한 익명 구현 객체가 되는 것이다. 

**타겟 타입**

타겟 타입은 람다식이 대입되는 인터페이스를 말한다. (위에서는 Runnable이 타겟 타입이다.)  모든 인터페이스가 람다식의 타겟 타입이 될 수는 없고 **하나의 추상 메소드만 선언**된 인터페이스만이 타겟 타입이 될 수 있다.

**@FunctionalInterface 어노테이션**

인터페이스가 하나의 추상 메소드만을 가지는지 컴파일러가 체크하도록 한다. 2개 이상의 추상 메소드를 가지면 오류가 난다.

< 주의점 >

- 람다식에서 사용하는 로컬 변수는 final 특성을 갖는다. 
- 이중 클래스이고 같은 이름의 변수가 있다면 람다식에서 this는 람다식이 쓰인 클래스의 인스턴스를 가르킨다. 



### 장점

1. 객체 생성 후 처리보다 데이터를 바로 처리하는 게 빠르다.
2. 코드가 간결해진다.

### 단점

1. 재사용성이 낮아진다. 
2. 가독성이 저하돼 코드 중복이 발생할 수 있다.

