## 데이터 타입 

자바의 데이터 타입은 기본 타입과 참조 타입으로 분류한다.

1. 기본 타입 (원시 타입)

   정수, 실수, 문자, 논리 리터럴 등 실제 값을 변수에 저장한다.

2. 참조 타입

   new 연산자로 힙 영역에 새로운 객체를 만들고 (실제 값은 힙 영역에 존재), 스택 영역에 생성된 변수에 메모리 번지를 저장한다. ex) 배열, 열거, 클래스, 인터페이스 타입. (클래스타입은 클래스의 메소드, 필드 등 사용 가능)

   

### 기본 타입

문자 저장은 char, 문자열을 저장하고 싶다면 **String** 타입을 사용해야 한다.

```java
String name = "이종은";
```

**long **타입 변수를 초기화 할때는 정수값 뒤에 L을 붙인다. 4byte 정수 데이터가 아니라 8byte 정수 데이터임을 컴파일러에게 알려주기 위해서이다. int 타입의 저장 범위를 넘어서는 큰 정수는 꼭 L을 붙인다.

```java
long var1=1000000000000; //컴파일 에러
long var2=1000000000000l;
```

자바는 **실수의 기본 타입**을 double로 본다. 따라서 실수 값을 float 타입 변수에 저장하려면 리터럴 뒤에 F를 붙여야 한다.

```java
double var1 = 3.14;
float var2 = 3.14; //컴파일 에러
float var3 = 3.14f;
```

**boolean **타입 (논리 타입)은 논리값을 **(true/false)** 저장할 수 있는 데이터 타입이다.

```java
boolean stop = true;
if(stop){
	System.out.println("중지합니다.");
}
```



### 타입 변환

**자동 타입 변환**

큰 크기 타입 = 작은 크기 타입

**강제 타입 변환** (casting)

작은 크기 타입 = (작은 크기 타입) 큰 크기 타입



### 연산자

```java
boolean result = (x+y) < 5;
```

x+y를 하고 나서 5보다 작은지 검사한 후 결과값 (true / false)을 변수에 저장한다.

**부호연산자의 산출 타입**은 int 타입이 된다.

```java
short s = 100;
short result = -s; //컴파일 에러
int result2 = -s;
```

**논리 부정 연산자**는 true를 false로, false를 true로 변경하기 때문에 boolean 타입에만 사용할 수 있다.

**비교 연산자**에서 String 타입 문자열을 비교할 대는 대소 연산자는 사용할 수 없고 동등 비교 연산자는 사용할 수 있다. (but 비교 연산자가 문자열이 같은지 다른지를 비교하지는 않는다.) 

```
String val = "이종은";
String val2 = "이종은";
String val3 = new String("이종은");
val == val2 //true
val2 == val3 //false
```

문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 한다. (동일한 문자열 리터럴은 공통 pool에 저장됨.) new로 만든 String 객체는 힙 영역에 저장 되고, 같은 내용의 문자열이라도 공유를 하지 않는다.



### 메소드

##### `equals() 메소드 `

객체의 문자열만을 비교할 수 있다. 

```java
boolean result = 원본문자열.equals(비교할문자열);
```

```java
package pr;

public class variable {
    public static void main(String[] args)
    {
        String a = "Hello world";
        String b = new String("Hello world");
        System.out.println(a == b); 
        //==은 두개의 데이터 타입이 동일한 객체인지를 알아내기 위해서 사용하는 연산자이기 때문에 값이 false
        System.out.println(a.equals(b)); 
        //.equals는 문자열을 비교할 때 사용하는 메소드
    }
}
```

**`==, != 연산`**

참조 타입 변수에서의 ==, != 연산은 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다. (주소값을 비교한다.)

##### `Math.random() 메소드`

0.0과 1.0 사이에 속하는 double 타입의 난수 하나를 리턴.

```java
int num = (int)(Math.random()*6)+1 //범위가 1과 6 사이인 정수 뽑기.
```





------

## 메모리 사용 영역

JVM은 운영체제에서 할당받은 메모리 영역을 세부 영역으로 구분해서 사용한다.

#### 메소드 영역

코드에서 사용되는 클래스들을 클래스 로더로 읽어 클래스 별로 (런타임 상수풀, 필드 데이터, 메소드 데이터, 메소드 코드, 생성자 코드 등) 분류해서 저장.

메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유한다.

#### 힙 영역

객체나 배열이 생성되는 영역. 힙 영역에 생성된 객체와 배열을 참조하는 JVM 스택 영역의 변수나 객체의 필드가 없다면 의미 없는 객체가 된다. -> 쓰레기로 취급하고 JVM은 쓰레기 수집기(Garbage Collector)를 실행시켜 쓰레기 객체를 힙 영역에서 자동으로 제거한다. (객체를 제거하기 위해 코드를 작성할 필요가 없다.)

#### JVM 스택 영역

각 스레드마다 하나씩 존재하고, 스레드가 시작될 때 할당된다. (스레드를 생성하지 않았다면 main 스레드만 존재하므로 JVM 스택도 하나임.) 

메소드를 호출할 때마다 프레임(Frame: 메소드가 호출될 때마다 만들어짐. 메소드 상태 정보 저장.)을 추가(push)하고 메소드가 종료되면 프레임을 제거(pop)하는 동작을 수행.

배열변수에는 배열의 힙 영역의 주소가 저장된다. (스택 영역에 생성.) java는 배열을 객체로 취급한다.