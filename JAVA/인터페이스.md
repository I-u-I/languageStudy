## 인터페이스

코드와 객체가 통신하는 접점 역할을 한다. 코드에서 인터페이스의 메소드를 호출하면 인터페이스는 생성된 객체의 메소드를 호출시킨다.

> 이것이 자바다에서 인터페이스는 객체의 사용 방법을 정의한 타입이라고 설명했다. 처음에는 이 말이 이해가 가지 않았다. 하지만 지금은 이해가 된다. 만약 Bank라는 인터페이스를 만들었다면, 어느 은행이든 Bank라는 인터페이스에 맞게 구현해야 한다. 은행에는 반드시 들어가야하는 메소드들이 있을테니 말이다. 인터페이스는 이걸 알려 주는 것이다.

그러니 인터페이스는 사용방법을 정의한 가이드라고 볼 수도 있고, 인터페이스를 사용하는 가장 큰 이유는 **동일한 목적 하에 동일한 기능을 보장하기 위함**이다.

- 하나의 클래스가 여러개의 인터페이스를 구현 할 수 있다.
- 인터페이스도 상속이 된다.
- **인터페이스의 멤버는 public이다.**

```java
pubilc interface 인터페이스명{
	타입 상수명 = 값; //상수
	
	타입 메소드명(매개변수,...); //추상 메소드
	
	default 타입 메소드명(매개변수,...) //디폴트 메소드
	{
		//구현부 
        
	}
	static 타입 메소드명(매개변수) //정적 메소드
	{
		//구현부
	}
}
```



### 멤버

인터페이스는 상수와 메소드만을 멤버로 가질 수 있다.

#### 1. 상수 필드

```java
타입 상수명 = 값;
```

#### 2. 추상 메소드

실행 블록이 필요 없다. 인터페이스의 추상메소드는 컴파일 과정에서 public abstract가 붙기 때문에 (public abstract 특성을 갖기 때문에) 생략이 가능하다.  인터페이스 객체를 선언한 후 호출해야 사용할 수 있다.

```java
리턴타입 메소드명(매개변수,...);
```

#### 3. 디폴트 메소드

인터페이스에서 바로 사용할 수 없다. (인터페이스.메소드명 이렇게 사용할 수 없다. 인터페이스의 구현 객체가 필요하다.) 오버라이딩 하여 재구현 할 수 있고 **선택적**이기 때문에 (인터페이스에서 제공해주지만 필요가 없다면 사용하지 않아도 된다. ) 유지보수성을 확보할 수 있다.

```java
default 리턴타입 메소드명(매개변수,...){...};
```

#### 4. 정적 메소드

**객체를 생성하지 않아도 인터페이스로 호출이 가능**하다. 인터페이스명.정적메소드명(매개값); 

```java
static 리턴타입 메소드명(매개변수,...){...};
```



### 구현

#### 클래스

```java
public class 구현클래스명 implements 인터페이스명{
    //...
}
```

- 추상 메소드에 대한 실체 메소드를 구현할 때 public보다 더 낮은 접근 제한은 사용할 수 없다. 
- 또 public을 생략할 수도 없다.

#### 객체

```java
인터페이스 변수명 = new 객체명();
```

#### 익명 구현 객체

그런데 객체를 한 번 사용하기 위해 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다. 그래서 익명 구현 객체를 이용한다.

```java
인터페이스 변수명 = new 인터페이스(){
    //인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}
```

밑에 더 자세한 설명으로 나온다.



### 배열

```java
인터페이스[] 변수명 ={new 구현객체(),new 구현객체(),...};
```



### 타입 변환

#### 자동 타입 변환

구현객체가 인터페이스 타입으로 변환되는 것이다. 인터페이스 구현 클래스를 상속해 자식 클래스를 만들었다면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환 시킬 수 있다.

```java
인터페이스 변수명 = 구현객체;
```

#### 강제 타입 변환

구현 객체가 인터페이스 타입으로 자동 변환하면 인터페이스에 선언된 메소드만 사용 가능하다. 그렇기에 강제 타입변환을 한다. 

```java
구현클래스 변수명 = (구현클래스) 인터페이스변수; 
//인터페이스변수는 구현객체를 자동타입변환 시킬 때 담았던 변수를 말한다
```

#### 타입 확인 (instanceof)

강제 타입 변환은 구현객체가 인터페이스 타입으로 변환되어있는 상태에서 가능하다.

```java
public void drive(인터페이스 A)
{
    Bus bus = (Bus) A;
}
```

메소드의 매개변수가 인터페이스로 선언된 경우, 메소드 호출 시 어떤 구현 객체들이 매개값으로 올 지 모른다. 만약 매개값으로 들어오는 값이 인터페이스 타입으로 변환되어있지 않은 구현 객체인데 강제타입변환 해버리면 오류가 발생한다. 

```java
if(변수 instanceof Bus) //A매개변수가 참조하는 객체가 Bus인지 조사
{
    Bus bus = (Bus) A;
}
```

이렇게 쓰면 오류를 피할 수 있다.



### 인터페이스의 다형성

#### 1. 필드의 다형성

인터페이스 타입에 어떤 구현 객체를 대입하느냐에 따라 실행 결과가 다양해진다.

``` java
// I i = new A(); 삭제
I i = new B(); // 수정

i.method1(); //
i.method2(); // 수정 필요 없음
```

위처럼 구현 객체를 교체해도 소스코드는 변함이 없다.

왜 필드의 다형성?

변수의 타입으로 인터페이스를 선언하게 될 때 구현 객체를 초기값으로 줄 수 있기 때문이다.

#### 2. 매개변수의 다형성

인터페이스 타입으로 매개 변수를 선언하면 메소드 호출 시 매개값으로 다양한 구현 객체를 줄 수 있기 때문에 인터페이스는 메소드의 매개 변수로 많이 쓰인다. 그리고 어떤 구현 객체가 매개값으로 오냐에따라 **메소드의 실행 결과**가 다양해진다.



### 상속

인터페이스도 다른 인터페이스를 상속할 수 있고, **다중 상속이 가능**하다. extends 뒤에 상속할 인터페이스들을 나열하면 된다. 하위 인터페이스의 구현 클래스는 하위 인터페이스의 메소드뿐만 아니라 상위 인터페이스의 메소드에 대한 실체 메소드도가지고 있어야한다.

하위 인터페이스로 타입 변환이 되면 상,하위인터페이스에 선언된 모든 메소드를 사용할 수 있다.

> **디폴트 메소드 재정의**

상속받을 인터페이스에 디폴트 메소드가 있으면 자식인터페이스에서 재정의 해서 사용할 수 있다. (물론 부모인터페이스에 있는 그대로 사용해도 된다. ) 재정의는 인터페이스에서도 할 수 있고 클래스를 만들어서도 할 수 있다.

또 부모인터페이스의 디폴트 메소드를 추상메소드로 재선언해도 된다.  (이것이 자바다 384p)



## 중첩 클래스

클래스 내부에 선언한 클래스이다. 

클래스가 여러 클래스와 관계를 맺을 땐 독립적으로 선언하고, 특정 클래스와 관계를 맺을 경우 관계 클래스 내부에 선언하는 게 좋다. (중첩 클래스.)

#### 1. 멤버 클래스

클래스의 멤버로서 선언되는 중첩 클래스. 재사용 가능.

- 인스턴스 멤버 클래스

  ```java
  class A{
      class B{...}
  }
  ```

  static 키워드 없이 선언된 클래스다. 인스턴스 필드와 인스턴스 메소드만 선언이 가능하다. (정적 필드, 정적 메소드 X.)

  바깥 클래스의 모든 멤버에 접근할 수 있다.

- 정적 멤버 클래스

  ```java
  class A{
      static class B{...}
  }
  ```

  static 키워드로 선언된 클래스다.  
  
  바깥 클래스의 인스턴스 필드와 인스턴스 메소드에는 접근할 수 없다.

##### 객체 생성

A 클래스 외부에서 B의 객체를 생성하는 법.

```java
//정적 클래스 객체 생성
A.B 변수명 = new A.B();
//인스턴스 클래스 객체 생성
A a = new A();
A.B b = a.new B();

변수.메소드(); //인스턴스 메소드 호출
A.C.메소드(); //정적 메소드 호출
```

#### 2. 로컬 클래스

메소드 내부에서 선언되는 중첩 클래스. **메소드가 종료되면 없어진다**. (메소드 내부에서만 사용됨.) 접근을 제한할 필요가 없어서 **접근 제한자를 붙일 수 없다**. 인스턴스 필드와 인스턴스 메소드만 선언이 가능하다.

```java
class A{
    void method(){
        class B{...}
    }
    B 변수명 = new B();
}
```

**메소드 내에서** 객체를 생성하고 **사용**해야 한다. (없어지기 때문.)

로컬 클래스에서 사용되는 매개 변수와 로컬 변수는 모두 **final 특성**을 갖는다. (그래서 한 번 선언된 변수는 **값 변경을 못 함**.) java 8 부터는 붙여주지 않아도 된다. 현재 로컬 크랠스에서 final의 존재 여부는 로컬 클래스의 복사 위치와 관련이 있다.



## 중첩인터페이스

클래스의 멤버로 선언된 인터페이스를 말한다. (인터페이스도 클래스 내부에 선언할 수 있다. 이것을 중첩 인터페이스라고 한다.)

**구현 클래스**는 implements 뒤에 **인터페이스선언클래스.인터페이스**를 써서 만든다. 

```java
public class Button{
    OnClick listecer; //인터페이스 타입 필드 
    interface onClickEvent{ //중첩 인터페이스
        void OnClick();
    }
}
```

```java
public class 클래스명 implements Button.OnClick{ 
    @Override
    public void OnClick(){
        System.out.println("굿");
    }
}
```

**언제 사용?**

아무객체나 받으면 안되고 클래스 내부에 선언된 중첩 인터페이스를 구현한 객체만 받아야 할 때 사용한다.

ex) button을 클릭햇을 때 이벤트를 처리하는 객체를 받고 싶다. 내부에 선언된 인터페이스의 onclick()을 구현한 객체를 받아야한다. 

#   

#   



## 익명 객체

### 익명 자식 객체

부모 타입으로 필드를 선언하고 자식 객체를 초기값으로 대입하기 위해선 (부모클래스를 상속받아 오버라이딩 하려면), 부모 클래스를 상속받을 자식 클래스를 선언 한 후 객체를 생성한다. (부모클래스 변수 = new 자식클래스();)

자식 클래스가 재사용되지 않고 오직 필드의 초기값으로만 사용된다면 익명 자식 객체를 초기값으로 대입하는 게 좋다. (일회성)

```java
부모클래스 변수 = new 부모클래스() {
	//처리구문 (필드, 메소드)
};
```

- 익명 클래스에서 **생성된** 메소드나 필드는 익명 클래스 밖에선 접근할 수 없다. 익명 자식 객체는 부모 타입 변수에 대입되기 때문에 부모 타입에 선언된 것만 사용할 수 있기 때문이다. 

- 메소드의 매개 변수가 부모 타입일 경우 메소드 호출에서 익명 자식 객체를 생성해 **매개값으로 대입**이 가능하다.

  넘길 때 new 부모 클래스(){실행 구문}을 매개변수로 넘기면 된다. 매개값을 받을 땐 (부모클래스타입 변수명)으로 받으면 된다.

  ``` java
  //넘길때
  object.method(new Person(){
  	String name = "Lee";
  	@Override
  	void whoAmI() {
  		System.out.println("나는 " + name + " 이다.");
  	}
  });
  ```

- **선언**은 클래스명.(필드명.)메소드명으로 한다.

### 익명 구현 객체

인터페이스 타입에 구현 객체를 초기값으로 대입하기 위해선 구현 클래스를 선언하고 구현 객체를 생성해야 한다. 구현 클래스가 재사용 되지 않고 오직 초기값으로만 사용하는 경우라면 익명 구현 객체를 초기값으로 대입하는 게 좋다.

익명 자식 객체와 비슷하다. 부모 클래스 대신 인터페이스가 들어갈 뿐이다. 클래스명.필드명.메소드로 구현한다. 역시 매개변수로도 전달이 가능하다.